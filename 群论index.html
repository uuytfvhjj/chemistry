<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>群论教学动画 - 分子对称性演示</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a237e 0%, #283593 100%);
            color: #f5f5f5;
            line-height: 1.6;
            min-height: 100vh;
            padding-bottom: 30px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: #bbdefb;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            font-size: 1.3rem;
            color: #90caf9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .visualization-panel {
            flex: 3;
            min-width: 300px;
        }
        
        .control-panel {
            flex: 2;
            min-width: 300px;
        }
        
        .info-panel {
            flex: 100%;
            min-width: 300px;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #bbdefb;
            border-bottom: 2px solid #3949ab;
            padding-bottom: 8px;
        }
        
        h3 {
            font-size: 1.4rem;
            margin: 20px 0 15px;
            color: #90caf9;
        }
        
        .molecule-container {
            width: 100%;
            height: 400px;
            background: rgba(0, 0, 0, 0.25);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        #molecule-canvas {
            width: 100%;
            height: 100%;
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #bbdefb;
        }
        
        select, button {
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        select:focus, button:focus {
            outline: 2px solid #3949ab;
        }
        
        .operation-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 15px;
        }
        
        .op-btn {
            flex: 1;
            min-width: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .op-btn i {
            font-size: 1.2rem;
        }
        
        .primary-btn {
            background: linear-gradient(to right, #3949ab, #5c6bc0);
        }
        
        .secondary-btn {
            background: linear-gradient(to right, #00695c, #00897b);
        }
        
        .symmetry-element {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .element-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .element-name {
            font-weight: bold;
            font-size: 1.2rem;
            color: #bbdefb;
        }
        
        .element-symbol {
            background: #3949ab;
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
        }
        
        .element-desc {
            font-size: 0.95rem;
            color: #e0e0e0;
        }
        
        .point-group-info {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .point-group-card {
            flex: 1;
            min-width: 200px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            transition: transform 0.3s ease;
        }
        
        .point-group-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .group-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #bbdefb;
            margin-bottom: 10px;
        }
        
        .group-example {
            font-style: italic;
            color: #90caf9;
            margin-bottom: 15px;
        }
        
        .group-desc {
            font-size: 0.95rem;
            color: #e0e0e0;
        }
        
        .math-concepts {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .concept {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
        }
        
        .concept-title {
            font-size: 1.3rem;
            color: #bbdefb;
            margin-bottom: 10px;
        }
        
        .concept-formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 1.1rem;
            margin: 15px 0;
            color: #fff;
            text-align: center;
        }
        
        .concept-desc {
            font-size: 0.95rem;
            color: #e0e0e0;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .oxygen {
            background-color: #ff5252;
        }
        
        .hydrogen {
            background-color: #448aff;
        }
        
        .carbon {
            background-color: #66bb6a;
        }
        
        .symmetry-axis {
            background-color: #ffb74d;
        }
        
        .symmetry-plane {
            background-color: #ab47bc;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #90caf9;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .subtitle {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-atom"></i> 群论与分子对称性</h1>
            <p class="subtitle">交互式教学动画 - 用于物理化学课程中群论概念的可视化演示</p>
        </header>
        
        <div class="main-content">
            <div class="panel visualization-panel">
                <h2>分子对称性可视化</h2>
                <div class="molecule-container">
                    <canvas id="molecule-canvas"></canvas>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color oxygen"></div>
                        <span>氧原子 (O)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color hydrogen"></div>
                        <span>氢原子 (H)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color carbon"></div>
                        <span>碳原子 (C)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color symmetry-axis"></div>
                        <span>对称轴</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color symmetry-plane"></div>
                        <span>对称面</span>
                    </div>
                </div>
            </div>
            
            <div class="panel control-panel">
                <h2>对称操作控制</h2>
                
                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">选择分子模型</label>
                        <select id="molecule-select">
                            <option value="h2o">水分子 (H₂O) - C₂v点群</option>
                            <option value="nh3">氨分子 (NH₃) - C₃v点群</option>
                            <option value="ch4">甲烷 (CH₄) - Td点群</option>
                            <option value="benzene">苯 (C₆H₆) - D₆h点群</option>
                            <option value="co2">二氧化碳 (CO₂) - D∞h点群</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">动画速度</label>
                        <select id="speed-select">
                            <option value="slow">慢速</option>
                            <option value="medium" selected>中速</option>
                            <option value="fast">快速</option>
                        </select>
                    </div>
                </div>
                
                <h3>对称操作</h3>
                <div class="operation-buttons">
                    <button class="op-btn primary-btn" id="rotate-btn">
                        <i class="fas fa-sync-alt"></i> 旋转操作 (Cₙ)
                    </button>
                    <button class="op-btn primary-btn" id="reflect-btn">
                        <i class="fas fa-expand-alt"></i> 反映操作 (σ)
                    </button>
                    <button class="op-btn primary-btn" id="invert-btn">
                        <i class="fas fa-retweet"></i> 反演操作 (i)
                    </button>
                    <button class="op-btn secondary-btn" id="identity-btn">
                        <i class="fas fa-redo"></i> 恒等操作 (E)
                    </button>
                    <button class="op-btn secondary-btn" id="reset-btn">
                        <i class="fas fa-undo"></i> 重置视图
                    </button>
                </div>
                
                <h3>对称元素</h3>
                <div id="symmetry-elements">
                    <!-- 对称元素将通过JavaScript动态加载 -->
                </div>
            </div>
            
            <div class="panel info-panel">
                <h2>点群分类与实例</h2>
                <div class="point-group-info">
                    <div class="point-group-card">
                        <div class="group-name">Cₙ 点群</div>
                        <div class="group-example">例如：H₂O (C₂v), NH₃ (C₃v)</div>
                        <div class="group-desc">具有一个n重旋转轴，可能有垂直的镜面</div>
                    </div>
                    <div class="point-group-card">
                        <div class="group-name">Dₙ 点群</div>
                        <div class="group-example">例如：交错式乙烷 (D₃d)</div>
                        <div class="group-desc">具有一个n重旋转轴和n个垂直于该轴的二重轴</div>
                    </div>
                    <div class="point-group-card">
                        <div class="group-name">Tₕ, T₄ 点群</div>
                        <div class="group-example">例如：CH₄ (T₄), 正四面体</div>
                        <div class="group-desc">具有多个高次旋转轴，属于立方体对称性</div>
                    </div>
                </div>
                
                <h2 style="margin-top: 30px;">群论基本概念</h2>
                <div class="math-concepts">
                    <div class="concept">
                        <div class="concept-title">群的四个公理</div>
                        <div class="concept-formula">闭合性 · 结合律 · 单位元 · 逆元</div>
                        <div class="concept-desc">
                            在分子对称操作中，所有对称操作的集合构成一个群。任何两个对称操作的组合仍然是该分子的对称操作。
                        </div>
                    </div>
                    <div class="concept">
                        <div class="concept-title">特征标表</div>
                        <div class="concept-formula">χ(E), χ(Cₙ), χ(σ), χ(i)</div>
                        <div class="concept-desc">
                            特征标表系统地描述了分子点群的不可约表示，对于确定分子轨道对称性和选择规则至关重要。
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>群论教学动画 | 物理化学对称性演示 | 使用Three.js与JavaScript构建</p>
            <p>用于教学目的 - 可扩展用于展示更多点群和对称操作</p>
        </div>
    </div>

    <!-- Three.js库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let moleculeGroup, symmetryElementsGroup;
        let currentMolecule = 'h2o';
        let animationInProgress = false;
        
        // 分子数据定义
        const molecules = {
            h2o: {
                name: "水分子 (H₂O)",
                pointGroup: "C₂v",
                atoms: [
                    { element: 'O', x: 0, y: 0, z: 0, color: 0xff5252, size: 0.5 },
                    { element: 'H', x: 0.76, y: 0.59, z: 0, color: 0x448aff, size: 0.3 },
                    { element: 'H', x: -0.76, y: 0.59, z: 0, color: 0x448aff, size: 0.3 }
                ],
                bonds: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 }
                ],
                symmetryElements: [
                    { type: 'axis', axis: 'y', order: 2, description: "C₂轴 (沿y轴)" },
                    { type: 'plane', normal: 'z', description: "σv镜面 (分子平面)" },
                    { type: 'plane', normal: 'x', description: "σv'镜面 (垂直于分子平面)" }
                ]
            },
            nh3: {
                name: "氨分子 (NH₃)",
                pointGroup: "C₃v",
                atoms: [
                    { element: 'N', x: 0, y: 0.3, z: 0, color: 0x66bb6a, size: 0.5 },
                    { element: 'H', x: 0.94, y: -0.2, z: 0, color: 0x448aff, size: 0.3 },
                    { element: 'H', x: -0.47, y: -0.2, z: 0.81, color: 0x448aff, size: 0.3 },
                    { element: 'H', x: -0.47, y: -0.2, z: -0.81, color: 0x448aff, size: 0.3 }
                ],
                bonds: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 },
                    { from: 0, to: 3 }
                ],
                symmetryElements: [
                    { type: 'axis', axis: 'y', order: 3, description: "C₃轴 (沿y轴)" },
                    { type: 'plane', normal: 'x', description: "σv镜面 (通过N和H1)" },
                    { type: 'plane', normal: [0.5, 0, 0.866], description: "σv镜面 (通过N和H2)" },
                    { type: 'plane', normal: [0.5, 0, -0.866], description: "σv镜面 (通过N和H3)" }
                ]
            },
            ch4: {
                name: "甲烷 (CH₄)",
                pointGroup: "Td",
                atoms: [
                    { element: 'C', x: 0, y: 0, z: 0, color: 0x66bb6a, size: 0.5 },
                    { element: 'H', x: 0.63, y: 0.63, z: 0.63, color: 0x448aff, size: 0.3 },
                    { element: 'H', x: -0.63, y: -0.63, z: 0.63, color: 0x448aff, size: 0.3 },
                    { element: 'H', x: -0.63, y: 0.63, z: -0.63, color: 0x448aff, size: 0.3 },
                    { element: 'H', x: 0.63, y: -0.63, z: -0.63, color: 0x448aff, size: 0.3 }
                ],
                bonds: [
                    { from: 0, to: 1 },
                    { from: 0, to: 2 },
                    { from: 0, to: 3 },
                    { from: 0, to: 4 }
                ],
                symmetryElements: [
                    { type: 'axis', axis: [1, 1, 1], order: 3, description: "C₃轴 (体对角线)" },
                    { type: 'axis', axis: 'x', order: 2, description: "C₂轴 (沿x轴)" },
                    { type: 'plane', normal: [1, 1, 0], description: "σd镜面 (通过两个H原子)" },
                    { type: 'inversion', description: "反演中心 (位于C原子)" }
                ]
            }
        };
        
        // 初始化Three.js场景
        function initScene() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a1931);
            
            // 创建相机
            camera = new THREE.PerspectiveCamera(45, document.getElementById('molecule-canvas').clientWidth / document.getElementById('molecule-canvas').clientHeight, 0.1, 1000);
            camera.position.set(5, 3, 5);
            camera.lookAt(0, 0, 0);
            
            // 创建渲染器
            const canvas = document.getElementById('molecule-canvas');
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            // 添加光源
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // 创建分子组和对称元素组
            moleculeGroup = new THREE.Group();
            symmetryElementsGroup = new THREE.Group();
            scene.add(moleculeGroup);
            scene.add(symmetryElementsGroup);
            
            // 添加坐标轴辅助
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            // 初始加载水分子
            loadMolecule(currentMolecule);
            
            // 设置窗口调整大小时的处理
            window.addEventListener('resize', onWindowResize);
            
            // 开始动画循环
            animate();
        }
        
        // 加载分子
        function loadMolecule(moleculeKey) {
            // 清除之前的分子和对称元素
            while(moleculeGroup.children.length > 0) {
                moleculeGroup.remove(moleculeGroup.children[0]);
            }
            
            while(symmetryElementsGroup.children.length > 0) {
                symmetryElementsGroup.remove(symmetryElementsGroup.children[0]);
            }
            
            const molecule = molecules[moleculeKey];
            
            // 创建原子
            molecule.atoms.forEach((atom, index) => {
                const geometry = new THREE.SphereGeometry(atom.size, 32, 32);
                const material = new THREE.MeshPhongMaterial({ color: atom.color });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(atom.x, atom.y, atom.z);
                moleculeGroup.add(sphere);
                
                // 添加原子标签
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 64;
                context.font = '48px Arial';
                context.fillStyle = '#ffffff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(atom.element, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(atom.x, atom.y + atom.size + 0.2, atom.z);
                sprite.scale.set(0.8, 0.8, 0.8);
                moleculeGroup.add(sprite);
            });
            
            // 创建化学键
            molecule.bonds.forEach(bond => {
                const atom1 = molecule.atoms[bond.from];
                const atom2 = molecule.atoms[bond.to];
                
                const start = new THREE.Vector3(atom1.x, atom1.y, atom1.z);
                const end = new THREE.Vector3(atom2.x, atom2.y, atom2.z);
                const distance = start.distanceTo(end);
                
                const direction = new THREE.Vector3().subVectors(end, start).normalize();
                const orientation = new THREE.Matrix4();
                orientation.lookAt(start, end, new THREE.Object3D().up);
                orientation.multiply(new THREE.Matrix4().makeRotationX(Math.PI / 2));
                
                const geometry = new THREE.CylinderGeometry(0.08, 0.08, distance, 8);
                const material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
                const cylinder = new THREE.Mesh(geometry, material);
                cylinder.applyMatrix4(orientation);
                cylinder.position.copy(start).add(direction.multiplyScalar(distance / 2));
                
                moleculeGroup.add(cylinder);
            });
            
            // 创建对称元素
            molecule.symmetryElements.forEach(element => {
                if (element.type === 'axis') {
                    // 创建旋转轴
                    const axisColor = 0xffb74d;
                    const axisLength = 4;
                    
                    let axisVector;
                    if (element.axis === 'x') axisVector = new THREE.Vector3(1, 0, 0);
                    else if (element.axis === 'y') axisVector = new THREE.Vector3(0, 1, 0);
                    else if (element.axis === 'z') axisVector = new THREE.Vector3(0, 0, 1);
                    else if (Array.isArray(element.axis)) axisVector = new THREE.Vector3(...element.axis);
                    
                    const geometry = new THREE.CylinderGeometry(0.05, 0.05, axisLength, 8);
                    const material = new THREE.MeshPhongMaterial({ color: axisColor });
                    const cylinder = new THREE.Mesh(geometry, material);
                    
                    // 对齐到轴方向
                    cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), axisVector.clone().normalize());
                    symmetryElementsGroup.add(cylinder);
                    
                    // 添加箭头
                    const coneGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
                    const cone = new THREE.Mesh(coneGeometry, material);
                    cone.position.copy(axisVector.clone().multiplyScalar(axisLength / 2));
                    cone.quaternion.copy(cylinder.quaternion);
                    symmetryElementsGroup.add(cone);
                    
                    // 添加反向箭头
                    const cone2 = cone.clone();
                    cone2.position.copy(axisVector.clone().multiplyScalar(-axisLength / 2));
                    cone2.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), axisVector.clone().negate().normalize());
                    symmetryElementsGroup.add(cone2);
                    
                    // 添加标签
                    const label = createTextSprite(`C${element.order || 'n'}轴`, 0.5, axisColor);
                    label.position.copy(axisVector.clone().multiplyScalar(axisLength / 2 + 0.5));
                    symmetryElementsGroup.add(label);
                    
                } else if (element.type === 'plane') {
                    // 创建对称面
                    const planeColor = 0xab47bc;
                    const planeSize = 3;
                    
                    let normalVector;
                    if (element.normal === 'x') normalVector = new THREE.Vector3(1, 0, 0);
                    else if (element.normal === 'y') normalVector = new THREE.Vector3(0, 1, 0);
                    else if (element.normal === 'z') normalVector = new THREE.Vector3(0, 0, 1);
                    else if (Array.isArray(element.normal)) normalVector = new THREE.Vector3(...element.normal);
                    
                    const geometry = new THREE.PlaneGeometry(planeSize, planeSize);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: planeColor, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.3
                    });
                    const plane = new THREE.Mesh(geometry, material);
                    
                    // 对齐到法线方向
                    plane.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), normalVector.clone().normalize());
                    symmetryElementsGroup.add(plane);
                    
                    // 添加边框
                    const edges = new THREE.EdgesGeometry(geometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: planeColor }));
                    line.quaternion.copy(plane.quaternion);
                    symmetryElementsGroup.add(line);
                    
                    // 添加标签
                    const label = createTextSprite("σ镜面", 0.5, planeColor);
                    label.position.copy(normalVector.clone().multiplyScalar(0.5));
                    symmetryElementsGroup.add(label);
                } else if (element.type === 'inversion') {
                    // 创建反演中心标记
                    const inversionColor = 0xff9800;
                    const geometry = new THREE.SphereGeometry(0.2, 16, 16);
                    const material = new THREE.MeshPhongMaterial({ color: inversionColor });
                    const sphere = new THREE.Mesh(geometry, material);
                    symmetryElementsGroup.add(sphere);
                    
                    // 添加标签
                    const label = createTextSprite("反演中心 i", 0.5, inversionColor);
                    label.position.set(0, 0.5, 0);
                    symmetryElementsGroup.add(label);
                }
            });
            
            // 更新对称元素信息显示
            updateSymmetryElementsDisplay(molecule.symmetryElements);
        }
        
        // 创建文本精灵
        function createTextSprite(text, size, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            
            context.fillStyle = `rgba(${color >> 16}, ${(color >> 8) & 0xff}, ${color & 0xff}, 0.8)`;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 40px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size, size/2, 1);
            
            return sprite;
        }
        
        // 更新对称元素信息显示
        function updateSymmetryElementsDisplay(elements) {
            const container = document.getElementById('symmetry-elements');
            container.innerHTML = '';
            
            elements.forEach((element, index) => {
                const div = document.createElement('div');
                div.className = 'symmetry-element';
                
                let symbol = '';
                if (element.type === 'axis') symbol = `C${element.order || 'n'}`;
                else if (element.type === 'plane') symbol = 'σ';
                else if (element.type === 'inversion') symbol = 'i';
                
                div.innerHTML = `
                    <div class="element-title">
                        <div class="element-name">${element.description}</div>
                        <div class="element-symbol">${symbol}</div>
                    </div>
                    <div class="element-desc">
                        ${getElementDescription(element)}
                    </div>
                `;
                
                container.appendChild(div);
            });
        }
        
        // 获取对称元素描述
        function getElementDescription(element) {
            if (element.type === 'axis') {
                return `一个${element.order || 'n'}重旋转轴，旋转${360/(element.order || 1)}°后分子与自身重合。`;
            } else if (element.type === 'plane') {
                return "一个镜面，通过该镜面反映后分子与自身重合。";
            } else if (element.type === 'inversion') {
                return "一个反演中心，通过该点反演后分子与自身重合。";
            }
            return "";
        }
        
        // 执行旋转操作
        function performRotation() {
            if (animationInProgress) return;
            animationInProgress = true;
            
            const molecule = molecules[currentMolecule];
            const axisElement = molecule.symmetryElements.find(el => el.type === 'axis');
            if (!axisElement) {
                animationInProgress = false;
                return;
            }
            
            let axisVector;
            if (axisElement.axis === 'x') axisVector = new THREE.Vector3(1, 0, 0);
            else if (axisElement.axis === 'y') axisVector = new THREE.Vector3(0, 1, 0);
            else if (axisElement.axis === 'z') axisVector = new THREE.Vector3(0, 0, 1);
            else if (Array.isArray(axisElement.axis)) axisVector = new THREE.Vector3(...axisElement.axis);
            
            const order = axisElement.order || 2;
            const angle = (2 * Math.PI) / order;
            const duration = 1500;
            const steps = 60;
            const stepAngle = angle / steps;
            let step = 0;
            
            function animateRotation() {
                if (step < steps) {
                    moleculeGroup.rotateOnWorldAxis(axisVector.normalize(), stepAngle);
                    step++;
                    setTimeout(animateRotation, duration / steps);
                } else {
                    // 确保最终位置准确
                    moleculeGroup.rotation.set(0, 0, 0);
                    moleculeGroup.rotateOnWorldAxis(axisVector.normalize(), angle);
                    animationInProgress = false;
                }
            }
            
            animateRotation();
        }
        
        // 执行反映操作
        function performReflection() {
            if (animationInProgress) return;
            animationInProgress = true;
            
            const molecule = molecules[currentMolecule];
            const planeElement = molecule.symmetryElements.find(el => el.type === 'plane');
            if (!planeElement) {
                animationInProgress = false;
                return;
            }
            
            // 创建镜像动画效果
            const duration = 1000;
            const steps = 30;
            let step = 0;
            
            // 找到镜面法线
            let normalVector;
            if (planeElement.normal === 'x') normalVector = new THREE.Vector3(1, 0, 0);
            else if (planeElement.normal === 'y') normalVector = new THREE.Vector3(0, 1, 0);
            else if (planeElement.normal === 'z') normalVector = new THREE.Vector3(0, 0, 1);
            else if (Array.isArray(planeElement.normal)) normalVector = new THREE.Vector3(...planeElement.normal);
            
            // 临时创建一个镜像分子
            const mirrorGroup = moleculeGroup.clone();
            mirrorGroup.traverse(function(child) {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            scene.add(mirrorGroup);
            
            // 动画：分子逐渐淡出，镜像分子逐渐淡入并移动到对称位置
            function animateReflection() {
                if (step < steps) {
                    const t = step / steps;
                    const mirrorT = t * 2;
                    
                    // 分子淡出
                    moleculeGroup.traverse(function(child) {
                        if (child.isMesh && child.material.opacity !== undefined) {
                            child.material.opacity = 1 - t;
                        }
                    });
                    
                    // 镜像分子淡入并移动
                    if (mirrorT <= 1) {
                        mirrorGroup.traverse(function(child) {
                            if (child.isMesh && child.material.opacity !== undefined) {
                                child.material.opacity = mirrorT;
                            }
                        });
                    } else {
                        // 移动到对称位置
                        const moveT = mirrorT - 1;
                        mirrorGroup.position.copy(normalVector.clone().multiplyScalar(-moveT * 0.5));
                    }
                    
                    step++;
                    setTimeout(animateReflection, duration / steps);
                } else {
                    // 完成动画：恢复原分子，移除镜像
                    moleculeGroup.traverse(function(child) {
                        if (child.isMesh && child.material.opacity !== undefined) {
                            child.material.opacity = 1;
                        }
                    });
                    
                    scene.remove(mirrorGroup);
                    
                    // 实际执行反映操作：沿法线方向反置坐标
                    moleculeGroup.children.forEach(child => {
                        if (child.position) {
                            if (normalVector.x !== 0) child.position.x *= -1;
                            if (normalVector.y !== 0) child.position.y *= -1;
                            if (normalVector.z !== 0) child.position.z *= -1;
                        }
                    });
                    
                    animationInProgress = false;
                }
            }
            
            animateReflection();
        }
        
        // 执行反演操作
        function performInversion() {
            if (animationInProgress) return;
            animationInProgress = true;
            
            const molecule = molecules[currentMolecule];
            const inversionElement = molecule.symmetryElements.find(el => el.type === 'inversion');
            if (!inversionElement) {
                animationInProgress = false;
                return;
            }
            
            // 动画：所有原子向中心收缩然后膨胀到对称位置
            const duration = 1500;
            const steps = 60;
            let step = 0;
            
            const originalPositions = [];
            moleculeGroup.children.forEach(child => {
                if (child.position && child.geometry && child.geometry.type === "SphereGeometry") {
                    originalPositions.push(child.position.clone());
                }
            });
            
            function animateInversion() {
                if (step < steps) {
                    const t = step / steps;
                    const scale = 1 - Math.sin(t * Math.PI) * 0.5;
                    
                    moleculeGroup.children.forEach((child, i) => {
                        if (child.position && child.geometry && child.geometry.type === "SphereGeometry") {
                            const originalPos = originalPositions[i];
                            child.position.x = originalPos.x * scale;
                            child.position.y = originalPos.y * scale;
                            child.position.z = originalPos.z * scale;
                        }
                    });
                    
                    step++;
                    setTimeout(animateInversion, duration / steps);
                } else {
                    // 完成反演：所有坐标取反
                    moleculeGroup.children.forEach(child => {
                        if (child.position) {
                            child.position.x *= -1;
                            child.position.y *= -1;
                            child.position.z *= -1;
                        }
                    });
                    
                    animationInProgress = false;
                }
            }
            
            animateInversion();
        }
        
        // 执行恒等操作
        function performIdentity() {
            if (animationInProgress) return;
            animationInProgress = true;
            
            // 恒等操作就是什么都不做，但我们可以展示一个简单的动画
            const duration = 1000;
            const steps = 30;
            let step = 0;
            
            // 存储原始位置
            const originalPositions = [];
            moleculeGroup.children.forEach(child => {
                if (child.position) {
                    originalPositions.push({
                        x: child.position.x,
                        y: child.position.y,
                        z: child.position.z
                    });
                }
            });
            
            function animateIdentity() {
                if (step < steps) {
                    const t = step / steps;
                    const pulse = Math.sin(t * Math.PI) * 0.1;
                    
                    moleculeGroup.children.forEach((child, i) => {
                        if (child.position && i < originalPositions.length) {
                            child.position.x = originalPositions[i].x * (1 + pulse);
                            child.position.y = originalPositions[i].y * (1 + pulse);
                            child.position.z = originalPositions[i].z * (1 + pulse);
                        }
                    });
                    
                    step++;
                    setTimeout(animateIdentity, duration / steps);
                } else {
                    // 恢复原始位置
                    moleculeGroup.children.forEach((child, i) => {
                        if (child.position && i < originalPositions.length) {
                            child.position.x = originalPositions[i].x;
                            child.position.y = originalPositions[i].y;
                            child.position.z = originalPositions[i].z;
                        }
                    });
                    
                    animationInProgress = false;
                }
            }
            
            animateIdentity();
        }
        
        // 重置视图
        function resetView() {
            camera.position.set(5, 3, 5);
            camera.lookAt(0, 0, 0);
            
            // 重置分子位置和旋转
            moleculeGroup.position.set(0, 0, 0);
            moleculeGroup.rotation.set(0, 0, 0);
            moleculeGroup.scale.set(1, 1, 1);
            
            // 重新加载分子以重置所有位置
            loadMolecule(currentMolecule);
        }
        
        // 窗口大小调整处理
        function onWindowResize() {
            const canvas = document.getElementById('molecule-canvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 缓慢旋转整个场景，方便查看3D结构
            if (!animationInProgress) {
                symmetryElementsGroup.rotation.y += 0.002;
            }
            
            renderer.render(scene, camera);
        }
        
        // 事件监听器设置
        function setupEventListeners() {
            // 分子选择
            document.getElementById('molecule-select').addEventListener('change', function() {
                currentMolecule = this.value;
                loadMolecule(currentMolecule);
            });
            
            // 操作按钮
            document.getElementById('rotate-btn').addEventListener('click', performRotation);
            document.getElementById('reflect-btn').addEventListener('click', performReflection);
            document.getElementById('invert-btn').addEventListener('click', performInversion);
            document.getElementById('identity-btn').addEventListener('click', performIdentity);
            document.getElementById('reset-btn').addEventListener('click', resetView);
            
            // 动画速度选择
            document.getElementById('speed-select').addEventListener('change', function() {
                // 这里可以调整动画速度，但目前的动画是硬编码的
                // 在实际应用中，可以根据这个值调整动画时长
            });
        }
        
        // 初始化
        document.addEventListener('DOMContentLoaded', function() {
            initScene();
            setupEventListeners();
        });
    </script>
</body>
</html>